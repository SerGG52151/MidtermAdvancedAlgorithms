% ==========================================================
% TC2038 - Minimalist Final Project Poster Template
% Requires: tec-logo.png in the same folder
% Compile with: pdflatex tc2038_poster.tex (preferably twice)
% ==========================================================
\documentclass[final]{beamer}

% ----------------------------------------------------------
% Poster size & layout - Full page usage
% ----------------------------------------------------------
\usepackage[size=a0,orientation=portrait,scale=1.25]{beamerposter}

% Remove all default margins
\setbeamersize{text margin left=0.5cm,text margin right=0.5cm}

% ----------------------------------------------------------
% Packages
% ----------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish,english]{babel}
\selectlanguage{english}

\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{multicol}
\usepackage{amsmath,amssymb}
\usepackage{url}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{tcolorbox}

% ----------------------------------------------------------
% Formal Color Palette
% ----------------------------------------------------------
\definecolor{primary}{RGB}{0,0,0}           % Pure black
\definecolor{secondary}{RGB}{60,60,60}      % Dark gray
\definecolor{accent}{RGB}{0,51,102}         % Navy blue
\definecolor{lightbg}{RGB}{255,255,255}     % Pure white
\definecolor{border}{RGB}{200,200,200}      % Medium gray border

% ----------------------------------------------------------
% Beamer Theme Settings
% ----------------------------------------------------------
\setbeamercolor{normal text}{fg=primary}
\setbeamercolor{structure}{fg=primary}

% Minimalist blocks with subtle borders
\setbeamercolor{block title}{fg=primary,bg=white}
\setbeamercolor{block body}{fg=primary,bg=white}

\setbeamerfont{title}{series=\bfseries,size=\VERYHuge}
\setbeamerfont{subtitle}{series=\normalfont,size=\large}
\setbeamerfont{author}{series=\normalfont,size=\normalsize}
\setbeamerfont{institute}{series=\normalfont,size=\normalsize}
\setbeamerfont{block title}{series=\bfseries,size=\large}
\setbeamerfont{block body}{size=\normalsize}

% Custom block template with formal styling - compact
\setbeamertemplate{block begin}{
  \vspace{0.4em}
  \begin{tcolorbox}[
    colback=white,
    colframe=border,
    boxrule=1pt,
    arc=0mm,
    left=5mm,
    right=5mm,
    top=3mm,
    bottom=3mm,
    leftrule=0pt,
    rightrule=1pt,
    toprule=0pt,
    bottomrule=1pt
  ]
  {\usebeamerfont{block title}\insertblocktitle}
  \vspace{0.2em}
  \par
}
\setbeamertemplate{block end}{
  \end{tcolorbox}
  \vspace{0.3em}
}


% ----------------------------------------------------------
% Formal Header - Full width
% ----------------------------------------------------------
\setbeamertemplate{headline}{
  \begin{minipage}[c]{0.12\paperwidth}
    \centering
    \includegraphics[width=2\linewidth]{tec-logo.png}
  \end{minipage}
  \begin{minipage}[c]{0.76\paperwidth}
    \centering
    {\usebeamerfont{title}\color{primary}\MakeUppercase{\inserttitle}\par}
    \vspace{0.2cm}
    {\usebeamerfont{subtitle}\color{secondary}\insertsubtitle\par}
    \vspace{0.3cm}
    {\usebeamerfont{author}\color{secondary}\insertauthor\par}
    \vspace{0.1cm}
    {\usebeamerfont{institute}\color{secondary}\insertinstitute\par}
    \vspace{0.05cm}
    {\usebeamerfont{institute}\color{secondary}\insertdate\par}
  \end{minipage}
  \begin{minipage}[c]{0.12\paperwidth}
    % Optional space for QR code or seal
  \end{minipage}
  \vspace{0.4cm}
  \begin{center}
    \color{border}\rule{0.98\paperwidth}{1pt}
  \end{center}
  \vspace{0.3cm}
}


% ----------------------------------------------------------
% Poster Title & Meta
% ----------------------------------------------------------
\title{\vspace{15cm}Optimized Graph Traversal Using Parallel A* Search}
\subtitle{Analysis and Design of Advanced Algorithms}
\author{Team Algorithms Plus}
\institute{Tecnológico de Monterrey}
\date{Fall 2025}

% ----------------------------------------------------------
% Formal Footer - Full width
% ----------------------------------------------------------
\setbeamertemplate{footline}{
  \vspace{0.3cm}
  \begin{center}
    \color{border}\rule{0.98\paperwidth}{1pt}
  \end{center}
  \vspace{0.2cm}
  \begin{center}
    {\small\color{secondary}
      TC2038 -- Analysis and Design of Advanced Algorithms\\
      \vspace{0.05cm}
      School of Engineering and Sciences, Computing Department\\
      \vspace{0.05cm}
      Tecnológico de Monterrey -- D.R.\textsuperscript{\textcopyright} ITESM 2025
    }
  \end{center}
  \vspace{0.3cm}
}

% Remove navigation symbols
\setbeamertemplate{navigation symbols}{}

% Customize itemize for formal style - compact
\setlist[itemize,1]{label=$\bullet$, leftmargin=*, itemsep=0.15em, parsep=0em, topsep=0.2em}
\setlist[itemize,2]{label=$\circ$, leftmargin=1.2em, itemsep=0.1em, parsep=0em, topsep=0.1em}

% ----------------------------------------------------------
% Document
% ----------------------------------------------------------
\begin{document}
\begin{frame}[t]

\begin{columns}[t,totalwidth=\textwidth]
% ===================== LEFT COLUMN ========================
\begin{column}{0.33\textwidth}

  \begin{block}{I. Project Overview}
    \textbf{Title:} Optimized Graph Traversal Using Parallel A* Search
    
    \vspace{0.2em}
    \textbf{Keywords:} Parallel algorithms $\cdot$ Graph theory $\cdot$ Heuristic search $\cdot$ A* optimization
    
    \vspace{0.3em}
    This project addresses the computational challenge of efficient pathfinding in large-scale graphs through a parallelized implementation of the A* search algorithm. The A* algorithm remains widely used due to its optimality guarantees and practical efficiency with admissible heuristics. However, as graph sizes grow into millions of vertices, sequential implementations face significant performance bottlenecks.
    
    \vspace{0.2em}
    The proposed approach demonstrates significant performance improvements through intelligent work distribution across multiple processor cores and careful optimization of shared data structures. Our parallel design maintains optimality guarantees while achieving near-linear speedup for moderately-sized thread pools.
  \end{block}

  \begin{block}{II. Objectives}
    \textbf{Primary Objective}

    To design, implement a reinforcement-learning-based approach to solve the Three-Utilities Problem on a toroidal grid, demonstrating optimal multi-agent pathfinding with cost minimization. This will be compared against the deterministic Conflict-Based Search (CBS) solution. 
    
    \vspace{0.2em}
    \textbf{Secondary Objectives}
    \begin{itemize}
      \item Implement CBS with Branch \& Bound to guarantee optimal solutions
      \item Develop constraint-based conflict resolution for multi-goal agent coordination
      \item Use toroidal Manhattan distance heuristic for admissible A* search
      \item Track performance metrics: total time steps (cost), makespan, and solution time
      \item Ensure agents complete round trips to each service location
      \item Validate conflict detection for both vertex and edge conflicts
    \end{itemize}
  \end{block}

  \begin{block}{III. Problem Statement}
    \textbf{Context and Motivation}
    
    The Three-Utilities Problem is a classic multi-agent pathfinding challenge where multiple agents must visit service locations without collisions. On toroidal grids (where edges wrap around), agents must coordinate to avoid vertex conflicts (occupying same position at same time) and edge conflicts (swapping positions). It is the ideal problem to compare the performance of CBS against MARL-for-MAPF.
    
    \vspace{0.2em}
    \textbf{Formal Specification}
    \begin{itemize}
      \item \textit{Input:} Toroidal grid $G$ of size $m \times m$, $n$ agents with start positions $S = \{s_1, \ldots, s_n\}$, each agent $i$ has goal list $G_i = \{g_{i,1}, \ldots, g_{i,k}\}$
      \item \textit{Output:} Conflict-free paths $P_1, \ldots, P_n$ where each $P_i$ visits all goals in $G_i$ with round trips to $s_i$, minimizing total cost $\sum_{i=1}^n |P_i|$
      \item \textit{Constraints:} No vertex conflicts (agents at same position/time), no edge conflicts (position swaps), agents return home after each service
      \item \textit{Objective:} Minimize makespan $\max_i |P_i|$ and total time steps $\sum_i |P_i|$ while guaranteeing optimality
    \end{itemize}
  \end{block}

\end{column}

% ===================== MIDDLE COLUMN =======================
\begin{column}{0.34\textwidth}

  \begin{block}{IV. Algorithm Design}
    \textbf{Algorithmic Paradigm}
    
    The solution implements Conflict-Based Search (CBS), a two-level algorithm combining high-level Branch \& Bound with low-level A* pathfinding. CBS explores a Constraint Tree (CT) where nodes represent constraint sets, branching on conflicts and bounding via cost-ordered priority queue.
    
    \vspace{0.2em}
    \textbf{Core Components}
    \begin{itemize}
      \item \textit{Low-level A*:} Toroidal grid pathfinding with O(1) constraint checking via reservation table; agents visit each goal with round trips (home→service→home)
      \item \textit{High-level CBS:} Branch on first conflict creating two child nodes (one constraint per agent); bound by total cost ensuring optimal solution
    \end{itemize}
    
    \vspace{0.2em}
    \textbf{Pseudocode (High-level CBS)}
    \begin{verbatim}
function CBS(starts, goals_list, grid):
  root_solution <- A*(each agent, empty set)
  conflicts <- detectConflicts(root_solution)
  cost <- sum(len(path) for all paths)
  open <- [(cost, conflicts, empty set, solution)]
  
  while open not empty:
    node = extractMin(open)
    if node.conflicts == empty set: 
      return node.solution
    conflict = node.conflicts[0]
    
    for constraint in branch(conflict):
      new path = A*(affected agent, constraints)
      if new path exists:
        child = createNode(new path, constraints)
        open.insert(child)
    \end{verbatim}
  \end{block}

  \begin{block}{V. Complexity Analysis}
    \begin{center}
    \renewcommand{\arraystretch}{1.3}
    \begin{tabular}{lc}
      \toprule
      \textbf{Measure} & \textbf{Bound} \\
      \midrule
      Low-level A* (single agent) & $O((|V|+|E|)\log|V|)$ \\
      CBS (worst case) & $O(b^k \cdot k \cdot A^*)$ \\
      Space (CT nodes) & $O(2^k)$ exponential branching \\
      Space (per A* call) & $O(|V| + |E|)$ \\
      \bottomrule
    \end{tabular}
    \end{center}
    
    \vspace{0.2em}
    \textbf{Theoretical Foundation}
    
    Low-level A* uses toroidal Manhattan distance heuristic (admissible), achieving $O((|V|+|E|)\log|V|)$ via priority queue. Space-time reservation table provides O(1) constraint checking (hash table lookup) versus O(k) linear search, where k = number of constraints. High-level CBS has worst-case exponential complexity in number of agents $k$ with branching factor $b=2$ per conflict. In practice, cost-first ordering (Branch \& Bound) prunes search space significantly. For $n$ agents on $m \times m$ grid visiting $g$ goals each, makespan is $O(ng \cdot m)$. Our implementation finds solutions in $<$10 iterations for 3-agent scenarios.
  \end{block}

\end{column}

% ===================== RIGHT COLUMN ========================
\begin{column}{0.33\textwidth}

  \begin{block}{VI. Experimental Results}
    \textbf{Experimental Setup}
    \begin{itemize}
      \item \textit{Implementation:} C++17 with OpenMP 4.5, GCC 11.2 (-O3)
      \item \textit{Hardware:} AMD Ryzen 9 5950X (16 cores @ 3.4 GHz), 64 GB DDR4-3200 RAM
      \item \textit{Test Suite:} Random planar graphs, grid graphs, real-world OpenStreetMap data
      \item \textit{Validation:} Dijkstra's algorithm as oracle; 1000 queries per graph size
    \end{itemize}
    
    \vspace{0.2em}
    \textbf{Performance Measurements}
    \begin{center}
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{cccc}
      \toprule
      \textbf{Size} & \textbf{Threads} & \textbf{Time} & \textbf{Speedup} \\
      \midrule
      $10^4$ & 1 & 142 ms & 1.00$\times$ \\
      $10^4$ & 8 & 28 ms & 5.07$\times$ \\
      $10^5$ & 1 & 1.89 s & 1.00$\times$ \\
      $10^5$ & 8 & 312 ms & 6.06$\times$ \\
      $10^6$ & 1 & 24.3 s & 1.00$\times$ \\
      $10^6$ & 8 & 3.8 s & 6.39$\times$ \\
      \bottomrule
    \end{tabular}
    \end{center}
    
    \vspace{0.2em}
    \textbf{Performance Visualization}
    
    \begin{center}
      \fbox{\includegraphics[width=0.88\linewidth,height=10cm,keepaspectratio]{graph-example.png}}
      
      \vspace{0.1em}
      {\small \textit{Figure 1: Execution time vs. graph size. Logarithmic scales. Error bars: 95\% CI over 1000 trials.}}
    \end{center}
    
    \vspace{0.2em}
    \textbf{Analysis}
    
    Results demonstrate near-linear speedup up to 8 threads with efficiency $E_8 \approx 0.75$. Performance gains diminish beyond 8 threads due to synchronization overhead (23\% of execution time) and memory bandwidth saturation. The parallel implementation maintains 100\% optimality across all test cases. Scalability validates theoretical predictions with synchronization accounting for approximately 25\% of parallel time.
  \end{block}

  \begin{block}{VII. Conclusions}
    This research successfully developed a parallel A* algorithm achieving 6.4$\times$ speedup on 8-core systems for million-vertex graphs. The implementation demonstrates correctness preservation through careful synchronization while delivering practical performance improvements.
    
    \vspace{0.2em}
    \textbf{Future Work}
    \begin{itemize}
      \item GPU-accelerated implementations using CUDA
      \item Bidirectional parallel A* for reduced search space
      \item Dynamic graphs with edge weight updates
      \item Lock-free priority queue implementations
    \end{itemize}
  \end{block}

  \begin{block}{VIII. References}
    {\small
    [1] Cormen et al. \textit{Intro to Algorithms}, 4th ed., MIT Press, 2022.
    
    [2] Hart, Nilsson, Raphael. A Formal Basis for Heuristic Path Search. \textit{IEEE Trans.}, 1968.
    
    [3] Burns et al. Implementing Fast Heuristic Search. \textit{SoCS}, 2012.
    
    [4] Zhou \& Hansen. Parallel Structured Duplicate Detection. \textit{AAAI}, 2007.
    }
  \end{block}

\end{column}
% =================== END COLUMNS ===========================
\end{columns}

\end{frame}
\end{document}